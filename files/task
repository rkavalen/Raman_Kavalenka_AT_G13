`000. NotEvenATask перечитать презентацию, сделать по отдельному классу на слайды 44 и 51, переписать код из них в main метод и разобраться, как он работает
`00. PreBaseTask (для него создаем отдельный пакет homework.day1.pretask, в каждом классе метод main, в теле которого выполняем само задание, там же и запускаем):

класс MessageExample, выведите на экран любое сообщение, которое вы хотите;
класс SumExample, посчитайте и выведите на экран сумму двух чисел (например, 5 + 7);
класс VariableExample, объявите две целочисленные переменные и выведите их значения на экран;
класс AnotherVariableExample, объявите две переменные с плавающей точкой (тип double) и присвойте им значения, выведите значения переменных на экран;
класс VariableAssignment, объявите целочисленную переменную и присвойте ей значение. Выведите значение на экран;
класс ConditionalExample, объявите целочисленную переменную и используйте условный оператор if, чтобы проверить, больше ли она 10, выведите результат проверки на экран;
класс NumberPrinting,  используйте цикл for и выведите на экран числа от 1 до 10;
класс SimpleLoopExample, объявите целочисленную переменную и используйте цикл for, чтобы вывести числа от 1 до этой переменной;
класс MathOperatorsExample, объявите две целочисленные переменные и выполните операции сложения, вычитания, умножения и деления, выведите результаты на экран;
класс VariableReassignment, объявите целочисленную переменную, переопределите её значение и выведите оба значения на экран;
класс ConditionalLoopExample, используйте цикл for, чтобы вывести четные числа от 1 до 10, с использованием условного оператора if для пропуска нечетных чисел;
класс MultiplicationTable, используя цикл for, выведите на экран таблицу умножения для числа 5 (1 * 5, 2 * 5, и так далее);
класс StringManipulationExample, объявите две строки, объедините их при помощи операции "+" и выведите результат на экран;
класс IncrementDecrementExample, объявите целочисленную переменную и используйте операторы инкремента и декремента для изменения её значения, выведите результаты на экран;
`0. BaseTask (для него создаем отдельный пакет homework.day1.basetask, обьекты классов задания запускаем в main методе отдельного класса раннера, далее "раннер")

создать класс TrainMethodsString и в нем
-- создать невозвратный метод printMama, который ничего не принимает на вход печатает в консоль «мама мыла раму»
-- создать невозвратный метод printPapa, который ничего не принимает на вход печатает в консоль «папа мыла раму»
-- создать невозвратный метод printString, который принимает на вход строку и печатает в консоль эту строку
-- создать невозвратный метод printMamaString, который принимает на вход строку и печатает в консоль «мама мыла » и эту строку
-- создать класс TrainMethodsStringRunner с методом main, в этом методе создать обьект класса TrainMethodsString и вызвать всего его методы
создать класс TrainMethodsPrimitive и в нем
-- создать невозвратный метод printInt, который принимает на вход целое число (int) и печатает в консоль «я получил на вход число » и это число
-- создать невозвратный метод printLong, который принимает на вход целое число (long) и печатает в консоль «я получил на вход  длинное число » и это число
-- создать невозвратный метод printChar, который принимает на вход символ (char) и печатает в консоль «я получил на вход символ » и это число
-- создать невозвратный метод printFloat, который принимает на вход дробное число (float) и печатает в консоль «я получил на вход дробное число » и это число
-- создать невозвратный метод printDouble, который принимает на вход дробное число (double) и печатает в консоль «я получил на вход длинное дробное число » и это число
-- создать невозвратный метод printShort, который принимает на вход целое число (short) и печатает в консоль «я получил на вход короткое число » и это число
-- создать невозвратный метод printByte, который принимает на вход целое число (byte) и печатает в консоль «я получил на вход очень короткое число » и это число
-- создать невозвратный метод printBoolean, который принимает на вход булево значение (boolean) и печатает в консоль «я получил на вход булево » и это число
-- создать класс TrainMethodsPrimitiveRunner с методом main, в этом методе создать обьект класса TrainMethodsPrimitive и вызвать всего его методы
создать класс TrainMethodsReturn и в нем
-- создать метод returnNewInt, который принимает на вход целое число (int) и возвращает это число умноженное на 3
-- создать метод returnNewLong, который принимает на вход целое число (long) и возвращает это число минус 4
-- создать метод returnNewChar, который принимает на вход символ (char) и возвращает строку из двух таких символов
-- создать метод returnNewFloat, который принимает на вход дробное число (float) и возвращает это число деленное на 2
-- создать метод returnNewDouble, который принимает на вход дробное число (double) и возвращает это число плюс 8
-- создать метод returnNewShort, который принимает на вход целое число (short) и возвращает это число минус 1
-- создать метод returnNewByte, который принимает на вход целое число (byte) и возвращает это число умноженное на 2
-- создать метод returnNewBoolean, который принимает на вход булево значение (boolean) и возвращает обратное булево
-- создать класс TrainMethodsReturnRunner с методом main, в котором создать обьект класса TrainMethodsReturn, и отпечатать в консоль значение, возвращаемое каждым из его методов в виде "метод <название метода> вернул " и возвращаемое значение
создать класс TrainMethodsIf и в нем
-- создать метод returnNewInt, который принимает на вход целое число (int) и если оно меньше 8, то возвращает это число умноженное на 7, в противном случае деленное на 4
-- создать метод returnNewLong, который принимает на вход целое число (long) и если оно больше 300, то возвращает это число минус 300, в противном случае плюс 20
-- создать метод returnNewChar, который принимает на вход символ (char) и если это 'g', то возвращает строку "go", в противном случае строку из этого символа с префиксом "o"
-- создать метод returnNewFloat, который принимает на вход дробное число (float) и если оно равно 0.67, то возвращает это число, в противном случае число умноженное на 2
-- создать метод returnNewDouble, который принимает на вход дробное число (double) и если оно больше 30, но меньше 80, то  возвращает это число плюс 87, если оно больше 80, но меньше 400, то возвращает это число минус 87, а если оно больше 400, то деленное на 4, в остальных случаях возвращает само число
-- создать невозвратный метод returnNewBoolean, который принимает на вход булево значение (boolean) и если оно true то печатает в консоль "Я получил на вход значение истины", в противном случае печатает в консоль "Я получил на вход ложь"
-- создать класс TrainMethodsIfRunner с методом main, в котором создать обьект класса TrainMethodsIf, и отпечатать в консоль значение, возвращаемое каждым из его методов в виде "метод <название метода> вернул " и возвращаемое значение, последний метод просто вызвать

создать класс Mouse и в нем
-- строковое поле name
-- целочисленное поле age
-- конструктор, принимающий имя и возраст и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printMouseDetails, который печатает в консоль информацию о мыши в виде "Я мышь, меня зовут <имя мыши> и мне <возраст мыши> лет"

создать класс Souce и в нем
-- строковое поле name
-- строковое поле color
-- конструктор, принимающий имя и цвет и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printSouceDetails, который печатает в консоль информацию о соусе в виде "Это соус <имя соуса> <цвет соуса> цвета"

создать класс Bee и в нем
-- строковое поле gender
-- длинное целочисленное поле weight
-- конструктор, принимающий пол и массу и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printBeeDetails, который делит 500 кг на массу пчелы и печатает в консоль информацию о ней в виде "Я легче лося в <> раз"

создать класс Obstacle и в нем
-- строковое поле description
-- строковое поле severity
-- конструктор, принимающий описание и важность и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printObstacleDetails, который печатает в консоль информацию о трудности в виде "Возникло <важность> препятствиие <описание препятствия>"

создать класс Pineapple и в нем
-- строковое поле grade
-- дробное числовое поле heatCapacity
-- конструктор, принимающий сорт и теплоемкость и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printPineappleDetails, который сравнивает теплоемкость ананаса с 2140 и если она больше, то печатает в консоль "Я ананас, теплоемкость которого больше, чем у ветчины", в противном случае печатает в консоль "В ветчине тепла запасется больше :("
создать класс TrainMethodsObjects и в нем
-- создать метод processMouse, который принимает на вход обьект мыши (Mouse) и печатает в консоль ее имя, возраст и вызывающий метод printMouseDetails
-- создать метод processSouce, который принимает на вход обьект соуса (Souce) и печатает в консоль его имя, цвет и вызывающий метод printSouceDetails
-- создать метод processBee, который принимает на вход обьект пчелы (Bee) и печатает в консоль ее пол, вес и вызывающий метод printBeeDetails
-- создать метод processObstacle, который принимает на вход обьект препятствия (Obstacle) и печатает в консоль его описание, важность и вызывающий метод printObstacleDetails
-- создать метод processPineapple, который принимает на вход обьект ананаса (Pineapple) и печатает в консоль его сорт, теплоемкость и вызывающий метод printPineappleDetails
-- создать класс TrainMethodsObjectsRunner с методом main, в котором создать обьект класса TrainMethodsObjects, и вызвать всего его методы
CycleTask (для него создаем отдельный пакет homework.day1.cycletask и каждое подзадание делаем в отдельном классе, имена классов и методов на ваше усмотрение, запускаем в отдельном классе CycleTaskRunner, где создаем обьект соответствующего типа и вызываем нужный метод)
-- используя while вывести в консоль все числа от 0 до 20 в 1 строку через пробел
-- используя for вывести в консоль каждое нечетное число от 3 до 19 включительно
-- создать пустой массив типа int и размера n = 7 и заполнить его случайными элементами используя Random.nextInt(n)
-- пройти по массиву и вывести в консоль все элементы
-- вывести в консоль все элементы массива в обратном порядке
-- каждый элемент массива умножить на 5 и вывести результат в консоль
-- каждый элемент массива возвести в квадрат и вывести результат в консоль
-- найти минимальный элемент массива и вывести результат в консоль
-- поменять местами первый и последний элементы и вывести результат в консоль
-- отсортировать элементы массива в порядке убывания (любым способом) и вывести результат в консоль

BubbleTask (для него создаем отдельный пакет project.bubbles)

-- создать класс Bubble
-- у пузырька должен быть обьем, газовый состав
-- он должен уметь лопаться с выводом в консоль «Cramp!»
-- обьем пузырька постоянный и равен 0.3 мм2,
а газовый состав переменный в зависимости от образующего газа
и задается в конструкторе класса

-- создать абстрактный класс Water
-- у воды есть такие характеристики, цвет, прозрачность, запах, температура

-- создать класс SparklingWater, являющийся дочерним Water
-- у газировки есть пузырьки
-- вода заполняется пузырьками при упаковке на заводе,
для этого у нее есть метод pump(Bubble[] bubbles)
-- 1 литр воды содержит 10 тыс пузырьков
-- у газировки есть метод degas(), который удаляет пузырьки по одному
и вызывает их лопанье

-- создать класс Bottle
-- у него есть обьем
-- есть вода
-- есть метод open(), который вызывает метод degas() в газировке

-- создать класс Runner, содержащий main
-- в нем создать 3 бутылки, объёмом 0.5, 1, 1.5 лира с газировкой
-- открыть поочередно все бутылки и выпустить из них газ

https://learngitbranching.js.org/
основное задание по гиту до следующего занятия, все, что там есть (основы и удаленные репозитории)

по максимуму доделываем предыдущее задание

пушаем все наработки в гитхаб (делать лушче не задолго перед занятием, чтобы комитнуть все ваши наработки):
-- на github.com создать git репозиторий с именем по маске Ivan_Ivanou_AT_G13 (как на слайдах, в теории у вас он уже есть, возможно нужно почистить от ненужного, а может пересоздать)
-- склонировать репозиторий к себе на компьютер (тоже если нужно, git clone, есть на слайдах)
-- скопировать все содержимое папки вашего проекта в IntelliJIdea в папку репозитория, по умолчанию ваш проект находится в C:\Users\<ваш_юзер>\IdeaProjects\ваш_проект (/home/<ваш_юзер>/IdeaProjects/ваш_проект для юникса), т.е. нужно буквально скопировать все содержимое папки проекта ../IntelliJIdea/ваш_проект в папку Ivan_Ivanou_AT_G13, которая создалась после клонирования репозитория (обычно нужно скопировать 2 папки - .idea и src и файлик .iml, если такой есть, и все, папку target и ее содержимое копировать НЕ НУЖНО!)
-- в файл .gitignore добавить 2 строки и сохранить файл:
/target
/build
-- открыть GitBash или терминал и перейти в папку вашего репозитория Ivan_Ivanou_AT_G13
-- добавить в гит все новые файлы, комитнуть и запушать весь код в гит репозиторий (git add, git commit, git push), пушать сразу в main
-- переоткрыть проект в IntelliJIdea из нового места (File -> Open) и далее продолжить работать только в нем, убедившись, что все хорошо, предыдущую папку с проектом можно удалить

`0. фоновое задание - вникнуть в ответ на вопрос, зачем в POJO классах переопределять методы hashCode(), equals() и toString()

реорганизация файлов (делают полностью или частично только те, кому это нужно)
-- убрать лишние файлы из гита, добавить их в гит-игнор (будет пояснение в сообщении позже)
-- перенести все файлы проекта в базовый пакет src (кому актуально)
-- в базовом пакете должны находиться только вложенные пакеты и НЕ ДОЛЖНО находиться самих файлов
-- в src создать 3 вложенных пакета: project, homework и classwork
-- в project перенести все файлы, которые касаются задания с пузырьками, все файлы должны быть помещены в какой-то пакет, логично показывающий принадлежность находящихся в нем файлов к некой общности (например, пакет boxing будет содержать такие классы, как Bottle, Box, Glass и т.п.)
-- в пакете classwork должны быть пакеты day1, day2 и т.п. с заданиями, которые вы делаете во время занятия, в пакете homework остальные домашние задания, не касающимися "проекта", так же сложенные по пакетам day1, day2
-- каждое новое задание должно быть в отдельном пакете с понятным названием
-- запушать все в гитхаб











отныне каждую домашку комитаем в гит:
a. для каждого задания создаем отдельную ветку с названием по маске hometask_day2_cycletask (day2 и homework.day1.cycletask меняем соответственно)
-- комитаем все в эту ветку
-- каждое под-задание (или его часть, сделанная за день) должен быть в виде отдельного комита
-- комиты можно пушать на гитхаб по мере их появления, но не реже 1 раза в день
b. на каждое задание должен быть пулл-реквест из рабочей ветки в мастер и споследующим мержем (более подробную инструкцию вышлю ниже)
 когда задание и все его под-задания выполнены, все комиты из рабочей ветки нужно запушать на github
-- на сайте github-а делаем пулл-реквест, и сами мержим в main, удаляем рабочую ветку, подтягиваем изменения main себе на компьютер (т.к. каждый раз нужно создавать новую рабочую ветку)
-- каждый день должно быть комитнутое задание или его часть на гит-хабе
вторая часть задания - пописать кода:

1.1 исправить в коде все, что я комментировал на занятии, доделать все задания, что были в первом задании с обьектами

работа с массивами и консолью (делаете в 1-м классе, имя класса произвольное)
-- написать метод, который принимает на вход целочисленный массив и считает сумму каждого n-ого элемента в нем, где n - целое число, передаваемое в сигнатуру этого метода вторым аргументом
-- написать метод, который вернет целочисленный массив, состоящий только из тех элементов исходного целочисленного массива (подается на вход этого метода), которые больше, чем число n, где n - целое число, передаваемое в сигнатуру этого метода вторым аргументом, элементы в результирующем массиве должны быть расположены в обратном порядке
-- написать метод, который вернет сумму тех элементов целочисленного массива, которые кратны первой цифре длины этого массива (массив подается в сигнатуру метода)
-- написать метод, который "нарисует" в консоли следующий рисунок:
      ^__^
      (oo)\\_______
     (__)\ ) \/\  \
          ||----w |\
          ||     ||

(и не мудрите, это простая последовательность из .println())


Playground task (пункты делаем ТОЛЬКО в том порядке, в котором они перечислены, каждый Task делаем в отдельной ветке и мержим через PR)

Playground Task 1:
создать классы:
package playground.essence
материя (Matter)
package playground.essence.creatures
животные (Animal): насекомые (Insect), позвоночные (Vertebrata)
насекомые: жук (Beetle), комар (Mosquito), муха (Fly)
позвоночные: голубь (Pigeon), ворон (Raven), крокодил (Crocodile)
растения (Plant): цветы (Flower), овощи (Vegetable)
цветы: ландыш (Maylily), роза (Rose), ромашка (Chamomile)
овощи: картошка (Potato), морковка (Carrot), редис (Radish)
package playground.essence.craft.air
воздушные транспортные средства (Aircraft): самолет (Plane), вертолет (Copter), ракета (Rocket)
package playground.essence.craft.field
наземные транспортные средства (Vehicle): автомобиль (Car), мотоцикл (Motorbike), мопед (Moped)
package playground.essence.craft.hand
емкости (Container): бутылка (Bottle), кружка (Mug), банка (Can)
package playground.essence.material
бензин (Petrol), дизельное топливо (Diesel), вода (Water)
материя, животные, насекомые, позвоночные, воздушные транспортные стредства, наземные транспортные стредства, емкости, растения, цветы, овощи - абстрактный классы, остальные их наследники
животные, растения, транспортные средства и емкости наследуются от материи, иерархия остальных классов согласна их перечислению



Playground Task 2:
добавить в классы характеристики и возможности:
-- у материи должно быть protected поле веса, int mass, конструктор, соответствующие геттеры и сеттеры
-- у животных, растений, транспортных стредств и емкостей должно быть protected поле имени, String name, конструктор, соответствующие геттеры и сеттеры
-- все животные имеют не абстрактный публичный метод void eat(Plant food) - принимает обьект растения и печатает в консоль фразу "I am N and I am eating D", где N - имя соответствующего обьекта класса животного, D - имя обьекта растения из передаваемого аргумента, использовать Format string syntax
-- все позвоночные имеют не абстрактный публичный метод void eat(Insect food) - принимает обьект насекомого и печатает в консоль фразу "I am N and I am eating D", где N - имя соответствующего обьекта класса позвоночного, D - имя обьекта насекомого из передаваемого аргумента, использовать Format string syntax
-- у жука есть не абстрактный публичный метод void nest(Carrot home) - принимает обьект морковки, сравнивает свою массу с массой последней и если его масса меньше, то печатает в консоль фразу "I am N and I will nest there with D my family members!", где N - имя соответствующего обьекта класса жука, D -  целая чать от деления массы моркови на массу жука, в противном случае печатает в консоль фразу "This carrot is too small for nesting :(", использовать, Format string syntax




Playground Task 3:
создать интерфейсы (которые реализуются соответствующими классами, согласно перечислению):
package playground.essence
летающие (Flyable): воздушные транспортные стредства, комар, муха
package playground.essence.craft
перемещающие (Transportable): воздушные транспортные стредства, наземные транспортные стредства
ездящие (Rideable): наземные транспортные стредства
package playground.essence.creatures;
ползающие (Crawlable): жук, крокодил
package playground.essence.craft.hand
хранящие (Storable): бутылка, банка
package playground.essence.material
льющиеся (Pourable): бензин, дизельное топливо, вода
питающие (Powerable): бензин, дизельное топливо
