`000. NotEvenATask перечитать презентацию, сделать по отдельному классу на слайды 44 и 51, переписать код из них в main метод и разобраться, как он работает
`00. PreBaseTask (для него создаем отдельный пакет homework.day1.pretask, в каждом классе метод main, в теле которого выполняем само задание, там же и запускаем):

класс MessageExample, выведите на экран любое сообщение, которое вы хотите;
класс SumExample, посчитайте и выведите на экран сумму двух чисел (например, 5 + 7);
класс VariableExample, объявите две целочисленные переменные и выведите их значения на экран;
класс AnotherVariableExample, объявите две переменные с плавающей точкой (тип double) и присвойте им значения, выведите значения переменных на экран;
класс VariableAssignment, объявите целочисленную переменную и присвойте ей значение. Выведите значение на экран;
класс ConditionalExample, объявите целочисленную переменную и используйте условный оператор if, чтобы проверить, больше ли она 10, выведите результат проверки на экран;
класс NumberPrinting,  используйте цикл for и выведите на экран числа от 1 до 10;
класс SimpleLoopExample, объявите целочисленную переменную и используйте цикл for, чтобы вывести числа от 1 до этой переменной;
класс MathOperatorsExample, объявите две целочисленные переменные и выполните операции сложения, вычитания, умножения и деления, выведите результаты на экран;
класс VariableReassignment, объявите целочисленную переменную, переопределите её значение и выведите оба значения на экран;
класс ConditionalLoopExample, используйте цикл for, чтобы вывести четные числа от 1 до 10, с использованием условного оператора if для пропуска нечетных чисел;
класс MultiplicationTable, используя цикл for, выведите на экран таблицу умножения для числа 5 (1 * 5, 2 * 5, и так далее);
класс StringManipulationExample, объявите две строки, объедините их при помощи операции "+" и выведите результат на экран;
класс IncrementDecrementExample, объявите целочисленную переменную и используйте операторы инкремента и декремента для изменения её значения, выведите результаты на экран;
`0. BaseTask (для него создаем отдельный пакет homework.day1.basetask, обьекты классов задания запускаем в main методе отдельного класса раннера, далее "раннер")

создать класс TrainMethodsString и в нем
-- создать невозвратный метод printMama, который ничего не принимает на вход печатает в консоль «мама мыла раму»
-- создать невозвратный метод printPapa, который ничего не принимает на вход печатает в консоль «папа мыла раму»
-- создать невозвратный метод printString, который принимает на вход строку и печатает в консоль эту строку
-- создать невозвратный метод printMamaString, который принимает на вход строку и печатает в консоль «мама мыла » и эту строку
-- создать класс TrainMethodsStringRunner с методом main, в этом методе создать обьект класса TrainMethodsString и вызвать всего его методы
создать класс TrainMethodsPrimitive и в нем
-- создать невозвратный метод printInt, который принимает на вход целое число (int) и печатает в консоль «я получил на вход число » и это число
-- создать невозвратный метод printLong, который принимает на вход целое число (long) и печатает в консоль «я получил на вход  длинное число » и это число
-- создать невозвратный метод printChar, который принимает на вход символ (char) и печатает в консоль «я получил на вход символ » и это число
-- создать невозвратный метод printFloat, который принимает на вход дробное число (float) и печатает в консоль «я получил на вход дробное число » и это число
-- создать невозвратный метод printDouble, который принимает на вход дробное число (double) и печатает в консоль «я получил на вход длинное дробное число » и это число
-- создать невозвратный метод printShort, который принимает на вход целое число (short) и печатает в консоль «я получил на вход короткое число » и это число
-- создать невозвратный метод printByte, который принимает на вход целое число (byte) и печатает в консоль «я получил на вход очень короткое число » и это число
-- создать невозвратный метод printBoolean, который принимает на вход булево значение (boolean) и печатает в консоль «я получил на вход булево » и это число
-- создать класс TrainMethodsPrimitiveRunner с методом main, в этом методе создать обьект класса TrainMethodsPrimitive и вызвать всего его методы
создать класс TrainMethodsReturn и в нем
-- создать метод returnNewInt, который принимает на вход целое число (int) и возвращает это число умноженное на 3
-- создать метод returnNewLong, который принимает на вход целое число (long) и возвращает это число минус 4
-- создать метод returnNewChar, который принимает на вход символ (char) и возвращает строку из двух таких символов
-- создать метод returnNewFloat, который принимает на вход дробное число (float) и возвращает это число деленное на 2
-- создать метод returnNewDouble, который принимает на вход дробное число (double) и возвращает это число плюс 8
-- создать метод returnNewShort, который принимает на вход целое число (short) и возвращает это число минус 1
-- создать метод returnNewByte, который принимает на вход целое число (byte) и возвращает это число умноженное на 2
-- создать метод returnNewBoolean, который принимает на вход булево значение (boolean) и возвращает обратное булево
-- создать класс TrainMethodsReturnRunner с методом main, в котором создать обьект класса TrainMethodsReturn, и отпечатать в консоль значение, возвращаемое каждым из его методов в виде "метод <название метода> вернул " и возвращаемое значение
создать класс TrainMethodsIf и в нем
-- создать метод returnNewInt, который принимает на вход целое число (int) и если оно меньше 8, то возвращает это число умноженное на 7, в противном случае деленное на 4
-- создать метод returnNewLong, который принимает на вход целое число (long) и если оно больше 300, то возвращает это число минус 300, в противном случае плюс 20
-- создать метод returnNewChar, который принимает на вход символ (char) и если это 'g', то возвращает строку "go", в противном случае строку из этого символа с префиксом "o"
-- создать метод returnNewFloat, который принимает на вход дробное число (float) и если оно равно 0.67, то возвращает это число, в противном случае число умноженное на 2
-- создать метод returnNewDouble, который принимает на вход дробное число (double) и если оно больше 30, но меньше 80, то  возвращает это число плюс 87, если оно больше 80, но меньше 400, то возвращает это число минус 87, а если оно больше 400, то деленное на 4, в остальных случаях возвращает само число
-- создать невозвратный метод returnNewBoolean, который принимает на вход булево значение (boolean) и если оно true то печатает в консоль "Я получил на вход значение истины", в противном случае печатает в консоль "Я получил на вход ложь"
-- создать класс TrainMethodsIfRunner с методом main, в котором создать обьект класса TrainMethodsIf, и отпечатать в консоль значение, возвращаемое каждым из его методов в виде "метод <название метода> вернул " и возвращаемое значение, последний метод просто вызвать

создать класс Mouse и в нем
-- строковое поле name
-- целочисленное поле age
-- конструктор, принимающий имя и возраст и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printMouseDetails, который печатает в консоль информацию о мыши в виде "Я мышь, меня зовут <имя мыши> и мне <возраст мыши> лет"

создать класс Souce и в нем
-- строковое поле name
-- строковое поле color
-- конструктор, принимающий имя и цвет и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printSouceDetails, который печатает в консоль информацию о соусе в виде "Это соус <имя соуса> <цвет соуса> цвета"

создать класс Bee и в нем
-- строковое поле gender
-- длинное целочисленное поле weight
-- конструктор, принимающий пол и массу и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printBeeDetails, который делит 500 кг на массу пчелы и печатает в консоль информацию о ней в виде "Я легче лося в <> раз"

создать класс Obstacle и в нем
-- строковое поле description
-- строковое поле severity
-- конструктор, принимающий описание и важность и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printObstacleDetails, который печатает в консоль информацию о трудности в виде "Возникло <важность> препятствиие <описание препятствия>"

создать класс Pineapple и в нем
-- строковое поле grade
-- дробное числовое поле heatCapacity
-- конструктор, принимающий сорт и теплоемкость и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printPineappleDetails, который сравнивает теплоемкость ананаса с 2140 и если она больше, то печатает в консоль "Я ананас, теплоемкость которого больше, чем у ветчины", в противном случае печатает в консоль "В ветчине тепла запасется больше :("
создать класс TrainMethodsObjects и в нем
-- создать метод processMouse, который принимает на вход обьект мыши (Mouse) и печатает в консоль ее имя, возраст и вызывающий метод printMouseDetails
-- создать метод processSouce, который принимает на вход обьект соуса (Souce) и печатает в консоль его имя, цвет и вызывающий метод printSouceDetails
-- создать метод processBee, который принимает на вход обьект пчелы (Bee) и печатает в консоль ее пол, вес и вызывающий метод printBeeDetails
-- создать метод processObstacle, который принимает на вход обьект препятствия (Obstacle) и печатает в консоль его описание, важность и вызывающий метод printObstacleDetails
-- создать метод processPineapple, который принимает на вход обьект ананаса (Pineapple) и печатает в консоль его сорт, теплоемкость и вызывающий метод printPineappleDetails
-- создать класс TrainMethodsObjectsRunner с методом main, в котором создать обьект класса TrainMethodsObjects, и вызвать всего его методы
CycleTask (для него создаем отдельный пакет homework.day1.cycletask и каждое подзадание делаем в отдельном классе, имена классов и методов на ваше усмотрение, запускаем в отдельном классе CycleTaskRunner, где создаем обьект соответствующего типа и вызываем нужный метод)
-- используя while вывести в консоль все числа от 0 до 20 в 1 строку через пробел
-- используя for вывести в консоль каждое нечетное число от 3 до 19 включительно
-- создать пустой массив типа int и размера n = 7 и заполнить его случайными элементами используя Random.nextInt(n)
-- пройти по массиву и вывести в консоль все элементы
-- вывести в консоль все элементы массива в обратном порядке
-- каждый элемент массива умножить на 5 и вывести результат в консоль
-- каждый элемент массива возвести в квадрат и вывести результат в консоль
-- найти минимальный элемент массива и вывести результат в консоль
-- поменять местами первый и последний элементы и вывести результат в консоль
-- отсортировать элементы массива в порядке убывания (любым способом) и вывести результат в консоль

BubbleTask (для него создаем отдельный пакет project.bubbles)

-- создать класс Bubble
-- у пузырька должен быть обьем, газовый состав
-- он должен уметь лопаться с выводом в консоль «Cramp!»
-- обьем пузырька постоянный и равен 0.3 мм2,
а газовый состав переменный в зависимости от образующего газа
и задается в конструкторе класса

-- создать абстрактный класс Water
-- у воды есть такие характеристики, цвет, прозрачность, запах, температура

-- создать класс SparklingWater, являющийся дочерним Water
-- у газировки есть пузырьки
-- вода заполняется пузырьками при упаковке на заводе,
для этого у нее есть метод pump(Bubble[] bubbles)
-- 1 литр воды содержит 10 тыс пузырьков
-- у газировки есть метод degas(), который удаляет пузырьки по одному
и вызывает их лопанье

-- создать класс Bottle
-- у него есть обьем
-- есть вода
-- есть метод open(), который вызывает метод degas() в газировке

-- создать класс Runner, содержащий main
-- в нем создать 3 бутылки, объёмом 0.5, 1, 1.5 лира с газировкой
-- открыть поочередно все бутылки и выпустить из них газ

https://learngitbranching.js.org/
основное задание по гиту до следующего занятия, все, что там есть (основы и удаленные репозитории)

по максимуму доделываем предыдущее задание

пушаем все наработки в гитхаб (делать лушче не задолго перед занятием, чтобы комитнуть все ваши наработки):
-- на github.com создать git репозиторий с именем по маске Ivan_Ivanou_AT_G13 (как на слайдах, в теории у вас он уже есть, возможно нужно почистить от ненужного, а может пересоздать)
-- склонировать репозиторий к себе на компьютер (тоже если нужно, git clone, есть на слайдах)
-- скопировать все содержимое папки вашего проекта в IntelliJIdea в папку репозитория, по умолчанию ваш проект находится в C:\Users\<ваш_юзер>\IdeaProjects\ваш_проект (/home/<ваш_юзер>/IdeaProjects/ваш_проект для юникса), т.е. нужно буквально скопировать все содержимое папки проекта ../IntelliJIdea/ваш_проект в папку Ivan_Ivanou_AT_G13, которая создалась после клонирования репозитория (обычно нужно скопировать 2 папки - .idea и src и файлик .iml, если такой есть, и все, папку target и ее содержимое копировать НЕ НУЖНО!)
-- в файл .gitignore добавить 2 строки и сохранить файл:
/target
/build
-- открыть GitBash или терминал и перейти в папку вашего репозитория Ivan_Ivanou_AT_G13
-- добавить в гит все новые файлы, комитнуть и запушать весь код в гит репозиторий (git add, git commit, git push), пушать сразу в main
-- переоткрыть проект в IntelliJIdea из нового места (File -> Open) и далее продолжить работать только в нем, убедившись, что все хорошо, предыдущую папку с проектом можно удалить

`0. фоновое задание - вникнуть в ответ на вопрос, зачем в POJO классах переопределять методы hashCode(), equals() и toString()

реорганизация файлов (делают полностью или частично только те, кому это нужно)
-- убрать лишние файлы из гита, добавить их в гит-игнор (будет пояснение в сообщении позже)
-- перенести все файлы проекта в базовый пакет src (кому актуально)
-- в базовом пакете должны находиться только вложенные пакеты и НЕ ДОЛЖНО находиться самих файлов
-- в src создать 3 вложенных пакета: project, homework и classwork
-- в project перенести все файлы, которые касаются задания с пузырьками, все файлы должны быть помещены в какой-то пакет, логично показывающий принадлежность находящихся в нем файлов к некой общности (например, пакет boxing будет содержать такие классы, как Bottle, Box, Glass и т.п.)
-- в пакете classwork должны быть пакеты day1, day2 и т.п. с заданиями, которые вы делаете во время занятия, в пакете homework остальные домашние задания, не касающимися "проекта", так же сложенные по пакетам day1, day2
-- каждое новое задание должно быть в отдельном пакете с понятным названием
-- запушать все в гитхаб
отныне каждую домашку комитаем в гит:
a. для каждого задания создаем отдельную ветку с названием по маске hometask_day2_cycletask (day2 и homework.day1.cycletask меняем соответственно)
-- комитаем все в эту ветку
-- каждое под-задание (или его часть, сделанная за день) должен быть в виде отдельного комита
-- комиты можно пушать на гитхаб по мере их появления, но не реже 1 раза в день
b. на каждое задание должен быть пулл-реквест из рабочей ветки в мастер и споследующим мержем (более подробную инструкцию вышлю ниже)
 когда задание и все его под-задания выполнены, все комиты из рабочей ветки нужно запушать на github
-- на сайте github-а делаем пулл-реквест, и сами мержим в main, удаляем рабочую ветку, подтягиваем изменения main себе на компьютер (т.к. каждый раз нужно создавать новую рабочую ветку)
-- каждый день должно быть комитнутое задание или его часть на гит-хабе
вторая часть задания - пописать кода:

1.1 исправить в коде все, что я комментировал на занятии, доделать все задания, что были в первом задании с обьектами

работа с массивами и консолью (делаете в 1-м классе, имя класса произвольное)
-- написать метод, который принимает на вход целочисленный массив и считает сумму каждого n-ого элемента в нем, где n - целое число, передаваемое в сигнатуру этого метода вторым аргументом
-- написать метод, который вернет целочисленный массив, состоящий только из тех элементов исходного целочисленного массива (подается на вход этого метода), которые больше, чем число n, где n - целое число, передаваемое в сигнатуру этого метода вторым аргументом, элементы в результирующем массиве должны быть расположены в обратном порядке
-- написать метод, который вернет сумму тех элементов целочисленного массива, которые кратны первой цифре длины этого массива (массив подается в сигнатуру метода)
-- написать метод, который "нарисует" в консоли следующий рисунок:
      ^__^
      (oo)\\_______
     (__)\ ) \/\  \
          ||----w |\
          ||     ||

(и не мудрите, это простая последовательность из .println())

Playground task (пункты делаем ТОЛЬКО в том порядке, в котором они перечислены, каждый Task делаем в отдельной ветке и мержим через PR)

Playground Task 1:
создать классы:
package playground.essence
материя (Matter)
package playground.essence.creatures
животные (Animal): насекомые (Insect), позвоночные (Vertebrata)
насекомые: жук (Beetle), комар (Mosquito), муха (Fly)
позвоночные: голубь (Pigeon), ворон (Raven), крокодил (Crocodile)
растения (Plant): цветы (Flower), овощи (Vegetable)
цветы: ландыш (Maylily), роза (Rose), ромашка (Chamomile)
овощи: картошка (Potato), морковка (Carrot), редис (Radish)
package playground.essence.craft.air
воздушные транспортные средства (Aircraft): самолет (Plane), вертолет (Copter), ракета (Rocket)
package playground.essence.craft.field
наземные транспортные средства (Vehicle): автомобиль (Car), мотоцикл (Motorbike), мопед (Moped)
package playground.essence.craft.hand
емкости (Container): бутылка (Bottle), кружка (Mug), банка (Can)
package playground.essence.material
бензин (Petrol), дизельное топливо (Diesel), вода (Water)
материя, животные, насекомые, позвоночные, воздушные транспортные стредства, наземные транспортные стредства, емкости, растения, цветы, овощи - абстрактный классы, остальные их наследники
животные, растения, транспортные средства и емкости наследуются от материи, иерархия остальных классов согласна их перечислению

Playground Task 2:
добавить в классы характеристики и возможности:
-- у материи должно быть protected поле веса, int mass, конструктор, соответствующие геттеры и сеттеры
-- у животных, растений, транспортных стредств и емкостей должно быть protected поле имени, String name, конструктор, соответствующие геттеры и сеттеры
-- все животные имеют не абстрактный публичный метод void eat(Plant food) - принимает обьект растения и печатает в консоль фразу "I am N and I am eating D", где N - имя соответствующего обьекта класса животного, D - имя обьекта растения из передаваемого аргумента, использовать Format string syntax
-- все позвоночные имеют не абстрактный публичный метод void eat(Insect food) - принимает обьект насекомого и печатает в консоль фразу "I am N and I am eating D", где N - имя соответствующего обьекта класса позвоночного, D - имя обьекта насекомого из передаваемого аргумента, использовать Format string syntax
-- у жука есть не абстрактный публичный метод void nest(Carrot home) - принимает обьект морковки, сравнивает свою массу с массой последней и если его масса меньше, то печатает в консоль фразу "I am N and I will nest there with D my family members!", где N - имя соответствующего обьекта класса жука, D -  целая чать от деления массы моркови на массу жука, в противном случае печатает в консоль фразу "This carrot is too small for nesting :(", использовать, Format string syntax

Playground Task 3:
создать интерфейсы (которые реализуются соответствующими классами, согласно перечислению):
package playground.essence
летающие (Flyable): воздушные транспортные стредства, комар, муха
package playground.essence.craft
перемещающие (Transportable): воздушные транспортные стредства, наземные транспортные стредства
ездящие (Rideable): наземные транспортные стредства
package playground.essence.creatures;
ползающие (Crawlable): жук, крокодил
package playground.essence.craft.hand
хранящие (Storable): бутылка, банка
package playground.essence.material
льющиеся (Pourable): бензин, дизельное топливо, вода
питающие (Powerable): бензин, дизельное топливо


Playground Task 4:
обновляем интерфейсы:
-- интерфейс летающие имеют невозвратный метод fly(String direction); - принимает строку направления движения и печатает в консоль фразу "I am N, my name is M and I amd flying to D", где N - название класса соответствующего обьекта, М - значение name обьекта, D - строка, подставляемая из значения передаваемого аргумента

создаем классы:
-- package playground.utils
-- class DirectionGenerator
у него есть публичный статический метод generateDirection() - который генерирует случайное число от 1 (включая) до 40 (исключая), и возвращает строку одного из 4-х значений направления, следуя логике, если случайное от 1 до 9 - NORTH, от 10 до 19 - SOUTH, от 20 до 29 - WEST, от 30 до 39 - EAST
-- package playground.processors
-- class FlyableProcessor
у него есть перегруженный публичный невозвратный метод:
runFlyable(Flyable flyable) - принимает обьект летающего и вызывает у него метод fly, которому передает случайное направления, которое генерируется вызовом метода generateDirection() из утилиты DirectionGenerator
runFlyable(Flyable flyable, String direction) - принимает обьект летающего и строку направления, и вызывает у первого метод fly, которому передает строку направления, переданную в качестве аргумента
выполняем код:
-- package playground.runners
-- class FlyableProcessorRunner с методом main, в котором
-- создать обьект класса FlyableProcessor
-- создать следующие обьекты:
Flyable flyableCopter = new Copter(223, "Mi8 Flyable");
Flyable flyablePlane = new Plane(3452, "Boeing 837 Flyable");
Flyable flyableRocket = new Rocket(7623, "Super Heavy Flyable");
Flyable flyableFly = new Fly(23, "Domestica Flyable");
Flyable flyableMosquito = new Mosquito(12, "Vulgaris Flyable");
Aircraft aircraftCopter = new Copter(223, "Mi8 Aircraft");
Aircraft aircraftPlane = new Plane(3452, "Boeing 837 Aircraft");
Aircraft aircraftRocket = new Rocket(7623, "Super Heavy Aircraft");
Insect insectFly = new Fly(23, "Domestica Insect");
Insect insectMosquito = new Mosquito(12, "Vulgaris Insect");
Copter aCopter = new Copter(223, "Mi8 Copter");
Plane aPlane = new Plane(3452, "Boeing 837 Plane");
Rocket aRocket = new Rocket(7623, "Super Heavy Rocket");
Fly aFly = new Fly(23, "Domestica Fly");
Mosquito aMosquito = new Mosquito(12, "Vulgaris Mosquito");
-- при помощи обьекта класса FlyableProcessor запустить runFlyable с каждым из обьектов из предыдущего пункта
-- в случае, если метод runFlyable не смог принять на вход обьект, закомментировать вызов метода и добавить пояснение причины
-- при помощи обьекта класса FlyableProcessor запустить runFlyable с 2-мя любыми обьектами Flyable и направлениями "никуда" и "повсюду"


Playground Task 5:
обновляем интерфейсы:
--перемещающие: имеют метод int move(int pointA, int pointB); - принимает 2 целых числа и печатает в консоль фразу "I am N, my name is M and I am moving from point A to point B", где N - название класса соответствующего обьекта, М - значение name обьекта, А и В - числа, подставляемые из значения передаваемых аргументов, и возвращает целое число, являющееся разницей В и А

создаем классы:
-- package playground.utils
-- class CoordinatesGenerator
у него есть публичный статический метод generateCoordinate() - который генерирует случайное число от 1 (включая) до 80 (исключая), печатает в консоль строку "CoordinatesGenerator: I have generated point with value: X", где Х - сгенерированное число, и возвращает это число

-- package playground.processors
-- class TransportableProcessor
у него есть перегруженный публичный невозвратный метод:
runTransportable(Transportable transportable, int pointA, int pointB) - принимает обьект перемещающего и числа точек перемещения А и В, и вызывает у первого метод move, которому передает точки перемещения, после чего печатает в консоль строку "Transportable N was moved to M points", где N - название класса соответствующего обьекта, M - получаемое значение расстояния в результате выполнения метода move
runTransportable(Transportable transportable) - принимает обьект перемещающего, и вызывает у него move, которому передает случайные значения точек перемещения, которые генерируется вызовами метода generateCoordinate() из утилиты CoordinatesGenerator, после чего печатает в консоль строку "Transportable N was moved to M points", где N - название класса соответствующего обьекта, M - получаемое значение расстояния в результате выполнения метода move
выполняем код:
-- package playground.runners
-- class TransportableProcessorRunner с методом main, в котором
-- создать обьект класса TransportableProcessor
-- создать следующие обьекты:
Transportable transportableCopter = new Copter(223, "AW109 Transportable");
Transportable transportablePlane = new Plane(3452, "Airbus a380 Transportable");
Transportable transportableRocket = new Rocket(7623, "Soyuz-FG Transportable");
Transportable transportableCar = new Car(23, "Tesla X Transportable");
Transportable transportableMoped = new Moped(12, "Honda EM1 Transportable");
Transportable transportableMotorbike = new Motorbike(12, "Suzuki GSX-R1000 Transportable");
Aircraft aircraftCopter = new Copter(223, "AW109 Aircraft");
Aircraft aircraftPlane = new Plane(3452, "Airbus a380 Aircraft");
Aircraft aircraftRocket = new Rocket(7623, "Soyuz-FG Aircraft");
Vehicle vehicleCar = new Car(23, "Tesla X Vehicle");
Vehicle vehicleMoped = new Moped(12, "Honda EM1 Vehicle");
Vehicle vehicleMotorbike = new Motorbike(12, "Suzuki GSX-R1000 Vehicle");
Flyable flyableCopter = new Copter(223, "AW109 Flyable");
Flyable flyablePlane = new Plane(3452, "Airbus a380 Flyable");
Flyable flyableRocket = new Rocket(7623, "Soyuz-FG Flyable");
Rideable rideableCar = new Car(23, "Tesla X Rideable");
Rideable rideableMoped = new Moped(12, "Honda EM1 Rideable");
Rideable rideableMotorbike = new Motorbike(12, "Suzuki GSX-R1000 Rideable");
Copter aCopter = new Copter(223, "AW109 Copter");
Plane aPlane = new Plane(3452, "Airbus a380 Plane");
Rocket aRocket = new Rocket(7623, "Soyuz-FG Rocket");
Car aCar = new Car(23, "Tesla X Car");
Moped aMoped = new Moped(12, "Honda EM1 Moped");
Motorbike aMotorbike = new Motorbike(12, "Suzuki GSX-R1000 Motorbike");
-- при помощи обьекта класса TransportableProcessor запустить runTransportable с каждым из обьектов из предыдущего пункта
-- в случае, если метод runTransportable не смог принять на вход обьект, закомментировать вызов метода и добавить пояснение причины
-- при помощи обьекта класса TransportableProcessor запустить runTransportable с 2-мя любыми обьектами Transportable и точеками перемещения 23 и 242, 93 и 7
String task (коллекции и потоки, которые можно найти в образцах кода в интернете или подсказках от идеи, категорически не использовать!), каждое подзадание выполняем в отдельном классе
1.1 сделать метод, который позволяет отпечатать в консоль все буквы в столбик из строки текста, которую принимает на вход в виде аргумента.
1.2 сделать метод, который позволяет найти и вывести в консоль все дубликаты слов в строке текста, который принимает на вход в виде аргумента.
1.3 сделать метод, который позволяет найти в тексте все цифры и преобразовать их в массив числовых переменных, вывести все элементы массива в косоль, текст получает на вход в виде аргумента
1.4 имеется текстовый лог в виде (ниже общий вид, т.е. частный случай):

access_log.2020.09.07 212.168.101.5 granted
access_log.2020.09.07 212.168.101.6 denied
access_log.2020.09.07 212.168.101.6 denied
access_log.2020.09.07 212.168.122.6 denied
написать метод, который принимает на вход текст лога и выводит список из уникальных IP адресов и количества удачных и неудачных попыток доступа в формате:
ip 212.168.101.5: ok - 3, failed - 2

1.5 написать метод, который выводит в консоль текущую дату и время в формате:
Сейчас на дворе: 19 сентября, 2020, 3 часа 13 минут

1.6 написать метод, который принимает на вход строку с датой и временем в формате "22.00 07.09.2020" и выводит в консоль в формате "September, 7, 2020 22:00"

1.7 написать метод, который принимает на вход строку текста и выводит в консоль дату, которая на n дней больше, чем текущая в формате "Сгенерированная гласная дата: 7 мая", где n - это количество гласных буков в получаемой строке

1.8 Создать класс StringObjectRunner, где в main методе создать по обьекту предыдущих классов и запустить выполнение созданных методов.

1.9 Переписать в отдельных классах все методы созданные в заданиях 1.1 - 1.7, сделав их статическими.

1.10 Создать класс StringStaticRunner, где в main методе запустить методы классов из предыдущего задания, обратившись к ним статически.


оздать класс обобщенного типа GenericMethodsInGenericClassT<T> и в нем:
-- невозвратный метод genericMethodOneGenArg, принимающий аргумент переменного типа и печатающий в консоль фразу "I am an object of X class", где X - название класса передаваемого аргумента
-- метод genericMethodTwoGenArgs, принимающий 2 аргумента переменного типа и возвращающий строку "We are objects of X class and Y class", где X и Y - название классов передаваемых аргументов
-- невозвратный метод genericMethodHalfGenArgs, принимающий 1 аргумент переменного типа и второй аргумент типа String, и печатающий в консоль фразу "I got an object of X class and string with N characters", где X - название класса передаваемых аргументов, N - количество символов в переданной строке

создать класс GenericMethodsInGenericClassTRunner с методом main и в нем:
-- создать обьекты типа GenericMethodsInGenericClassT<T> с параметрами типа String, Integer, Double и всеми типами, которые содержаться в пакете playground.essence
-- вызывать каждый из методов у каждого из обьектов, в случае, если метод возвратный - отпечатать возвращаемое им значение в консоль
создать класс обобщенного типа GenericMethodsInGenericClassTwoParams<X, Y> и в нем:
-- перегруженный метод genericMethodGenArgs, принимающий 1 или 2 аргумента переменного типа и возвращающий строку "I received N arguments of type: X class, Y class", где N - количество полученных аргументов, X и Y - название классов передаваемых аргументов
-- перегруженный невозвратный метод genericMethodHalfGenArgs, принимающий 1 или 2 аргумента переменного типа и второй или третитй аргумент типа String, и печатающий в консоль фразу "I got an object of X class and Y class and string with N characters", где X - название класса передаваемых аргументов, N - количество символов в переданной строке, перегрузку метода сделать для вариантов параметров типа (X, String), (Y, String)
создать класс GenericMethodsInGenericClassTwoParamsRunner с методом main и в нем:
-- создать обьекты типа GenericMethodsInGenericClassTwoParams <X, Y> с параметрами типа <String, String>, <String, Integer>, <String, Double>,  <Integer, Integer> и всеми типами, которые содержаться в пакете playground.essence, используя каждый из них хотя бы 1 раз
-- вызывать каждый из методов у каждого из обьектов, в случае, если метод возвратный - отпечатать возвращаемое им значение в консоль